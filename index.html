<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–®–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω—ã–π –°–∞–ø—ë—Ä</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: bold;
            color: #555;
        }

        select, button {
            padding: 10px 20px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        select {
            background: white;
            color: #333;
        }

        button {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            font-size: 1.2em;
            font-weight: bold;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-value {
            color: #667eea;
            font-size: 1.5em;
        }

        .board-container {
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 20px;
            width: 100%;
            height: 60vh;
            min-height: 400px;
            max-height: 800px;
            background: #f5f5f5;
            border-radius: 10px;
            margin: 20px 0;
        }

        .hex-board {
            position: absolute;
        
            
            transform-origin: center center;
        }

        .hex-cell {
            position: absolute;
            width: 60px;
            height: 60px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .hex-cell:hover:not(.opened):not(.flagged) {
            transform: scale(1.1);
            z-index: 10;
        }

        .hex-cell svg {
            width: 100%;
            height: 100%;
        }

        .hex-cell svg polygon.closed {
            fill: #d0d8e0;
            stroke: #7a8a9a;
            stroke-width: 3;
        }

        .hex-cell:hover svg polygon.closed {
            fill: #c0d0e0;
        }

        .hex-cell svg polygon.opened {
            fill: #ffffff;
            stroke: #bbb;
            stroke-width: 1;
        }

        .hex-cell svg polygon.flagged {
            fill: #ff6b6b;
        }

        .hex-cell svg polygon.mine {
            fill: #ff0000;
        }

        .hex-cell svg polygon.exploded {
            fill: #ff0000;
            animation: explode 0.3s;
        }

        @keyframes explode {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .hex-text {
            pointer-events: none;
            font-size: 50px;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
        }

        .hex-text.number-1 { fill: #0000ff; }
        .hex-text.number-2 { fill: #008000; }
        .hex-text.number-3 { fill: #ff0000; }
        .hex-text.number-4 { fill: #000080; }
        .hex-text.number-5 { fill: #800000; }
        .hex-text.number-6 { fill: #008080; }
        .hex-text.flag { fill: white; font-size: 40px; }
        .hex-text.mine { fill: black; font-size: 50px; }

        .game-over, .game-won {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            text-align: center;
            z-index: 1000;
        }

        .game-over h2 {
            color: #ff0000;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .game-won h2 {
            color: #00aa00;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üí£ –®–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω—ã–π –°–∞–ø—ë—Ä</h1>
        
        <div style="text-align: center; margin-bottom: 20px; padding: 12px; background: #e8f4f8; border-radius: 8px; color: #2c5f7c; font-size: 1em; border: 2px solid #667eea;">
            üí° <strong>–ö–∞–∫ –∏–≥—Ä–∞—Ç—å:</strong> 
            <span id="desktopHint">–õ–µ–≤—ã–π –∫–ª–∏–∫ - –æ—Ç–∫—Ä—ã—Ç—å | –ü—Ä–∞–≤—ã–π –∫–ª–∏–∫ - —Ñ–ª–∞–≥ üö©</span>
            <span id="mobileHint" style="display: none;">–ù–∞–∂–º–∏—Ç–µ - –æ—Ç–∫—Ä—ã—Ç—å | –î–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ - —Ñ–ª–∞–≥ üö©</span>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="sizeSelect">–†–∞–∑–º–µ—Ä –ø–æ–ª—è:</label>
                <select id="sizeSelect" onchange="newGame()">
                    <option value="5">5</option>
                    <option value="7">7</option>
                    <option value="9" selected>9</option>
                    <option value="11">11</option>
                    <option value="13">13</option>
                    <option value="15">15</option>
                    <option value="17">17</option>
                    <option value="19">19</option>
                    <option value="21">21</option>
                </select>
            </div>
            <button onclick="newGame()">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        </div>

        <div class="stats">
            <div class="stat">
                <span>–§–ª–∞–≥–∏:</span>
                <span class="stat-value" id="flagsCount">0</span>
            </div>
            <div class="stat">
                <span>–ú–∏–Ω:</span>
                <span class="stat-value" id="minesCount">0</span>
            </div>
            <div class="stat">
                <span>–û—Ç–∫—Ä—ã—Ç–æ:</span>
                <span class="stat-value" id="openedCount">0</span>
            </div>
        </div>

        <div class="board-container">
            <div id="hexBoard" class="hex-board"></div>
        </div>
    </div>

    <div id="gameOver" class="game-over hidden">
        <h2>üí• –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</h2>
        <p>–í—ã –ø–æ–¥–æ—Ä–≤–∞–ª–∏—Å—å –Ω–∞ –º–∏–Ω–µ</p>
        <button onclick="newGame()" style="margin-top: 20px;">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
    </div>

    <div id="gameWon" class="game-won hidden">
        <h2>üéâ –ü–æ–±–µ–¥–∞!</h2>
        <p>–í—ã –Ω–∞—à–ª–∏ –≤—Å–µ –º–∏–Ω—ã!</p>
        <button onclick="newGame()" style="margin-top: 20px;">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
    </div>

    <script>
        let gameState = {
            size: 9,
            mines: [],
            opened: new Set(),
            flagged: new Set(),
            board: [],
            gameOver: false,
            gameWon: false,
            firstClick: true
        };

        // –ë–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è —à–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–æ–π —Å–µ—Ç–∫–∏ (–±—É–¥–µ—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å—Å—è)
        const BASE_HEX_SIZE = 30;

        // –°–æ—Å–µ–¥–∏ –≥–µ–∫—Å–∞–≥–æ–Ω–∞ –≤ –æ—Å–µ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö (q, r)
        const HEX_NEIGHBORS = [
            [1, 0], [1, -1], [0, -1],
            [-1, 0], [-1, 1], [0, 1]
        ];

        function hexToPixel(q, r, hexSize) {
            const hexWidth = Math.sqrt(3) * hexSize;
            const hexHeight = 2 * hexSize;
            const x = hexWidth * (q + r / 2);
            const y = hexHeight * r * 0.75;
            return { x, y };
        }

        function generateHexagonalBoard(size) {
            const board = [];
            const hexes = [];
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —à–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–æ–µ –ø–æ–ª–µ
            // –†–∞–∑–º–µ—Ä –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ä–∞–¥–∏—É—Å —à–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫–∞ (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–ª–µ—Ü –æ—Ç —Ü–µ–Ω—Ç—Ä–∞)
            // –†–∞–∑–º–µ—Ä 5 = —Ä–∞–¥–∏—É—Å 2, —Ä–∞–∑–º–µ—Ä 7 = —Ä–∞–¥–∏—É—Å 3 –∏ —Ç.–¥.
            const radius = Math.floor(size / 2);
            
            for (let q = -radius; q <= radius; q++) {
                const r1 = Math.max(-radius, -q - radius);
                const r2 = Math.min(radius, -q + radius);
                for (let r = r1; r <= r2; r++) {
                    board.push({ q, r });
                    hexes.push({ q, r });
                }
            }
            
            return { board, hexes };
        }

        function placeMines(board, count, excludeSet) {
            const mines = new Set();
            const available = board.filter(hex => 
                !excludeSet.has(`${hex.q},${hex.r}`)
            );
            
            // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –º–∞—Å—Å–∏–≤ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–ª–µ—Ç–æ–∫
            const shuffled = available.sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < Math.min(count, shuffled.length); i++) {
                const hex = shuffled[i];
                mines.add(`${hex.q},${hex.r}`);
            }
            
            return mines;
        }

        function countAdjacentMines(q, r, mines) {
            let count = 0;
            for (const [dq, dr] of HEX_NEIGHBORS) {
                const nq = q + dq;
                const nr = r + dr;
                if (mines.has(`${nq},${nr}`)) {
                    count++;
                }
            }
            return count;
        }

        function getAdjacentHexes(q, r, board) {
            const adjacent = [];
            const boardMap = new Map(board.map(h => [`${h.q},${h.r}`, h]));
            
            for (const [dq, dr] of HEX_NEIGHBORS) {
                const nq = q + dq;
                const nr = r + dr;
                const key = `${nq},${nr}`;
                if (boardMap.has(key)) {
                    adjacent.push({ q: nq, r: nr });
                }
            }
            
            return adjacent;
        }

        function openCell(q, r, board, mines, opened, flagged) {
            const key = `${q},${r}`;
            
            if (opened.has(key) || flagged.has(key)) {
                return;
            }
            
            opened.add(key);
            
            if (mines.has(key)) {
                return 'mine';
            }
            
            const count = countAdjacentMines(q, r, mines);
            
            if (count === 0) {
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Å–æ—Å–µ–¥–Ω–∏–µ –ø—É—Å—Ç—ã–µ –∫–ª–µ—Ç–∫–∏
                const adjacent = getAdjacentHexes(q, r, board);
                for (const adj of adjacent) {
                    openCell(adj.q, adj.r, board, mines, opened, flagged);
                }
            }
            
            return count;
        }

        function renderBoard() {
            const boardEl = document.getElementById('hexBoard');
            if (!boardEl) {
                console.error('hexBoard element not found!');
                return;
            }
            
            boardEl.innerHTML = '';
            
            // –í—Å–µ–≥–¥–∞ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤–æ–µ –ø–æ–ª–µ, –µ—Å–ª–∏ board –ø—É—Å—Ç–æ–π
            if (!gameState.board || gameState.board.length === 0) {
                const { board: newBoard } = generateHexagonalBoard(gameState.size);
                gameState.board = newBoard;
                console.log('Generated new board with', newBoard.length, 'cells, size:', gameState.size);
            }
            
            const board = gameState.board;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –∫–ª–µ—Ç–∫–∏ –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
            if (!board || board.length === 0) {
                console.error('Board is empty! Size:', gameState.size);
                return;
            }
            
            console.log('Rendering board with', board.length, 'cells');
            
            // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
            let minQ = Infinity, maxQ = -Infinity;
            let minR = Infinity, maxR = -Infinity;
            
            for (const hex of board) {
                minQ = Math.min(minQ, hex.q);
                maxQ = Math.max(maxQ, hex.q);
                minR = Math.min(minR, hex.r);
                maxR = Math.max(maxR, hex.r);
            }
            
            const centerQ = (minQ + maxQ) / 2;
            const centerR = (minR + maxR) / 2;
            
            // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
            const containerRect = boardEl.parentElement.getBoundingClientRect();
            const containerWidth = containerRect.width - 40; // –í—ã—á–∏—Ç–∞–µ–º padding
            const containerHeight = containerRect.height - 40;
            
            // –í—ã—á–∏—Å–ª—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª—è —Å –±–∞–∑–æ–≤—ã–º —Ä–∞–∑–º–µ—Ä–æ–º
            // –ü–æ—Å–ª–µ –≤—ã—á–∏—Ç–∞–Ω–∏—è centerQ/centerR, —Ü–µ–Ω—Ç—Ä –ø–æ–ª—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—Ä–∏–º–µ—Ä–Ω–æ –≤ (0,0)
            const bounds = {
                left: Infinity, right: -Infinity,
                top: Infinity, bottom: -Infinity
            };
            
            board.forEach(hex => {
                const pos = hexToPixel(hex.q - centerQ, hex.r - centerR, BASE_HEX_SIZE);
                bounds.left = Math.min(bounds.left, pos.x);
                bounds.right = Math.max(bounds.right, pos.x);
                bounds.top = Math.min(bounds.top, pos.y);
                bounds.bottom = Math.max(bounds.bottom, pos.y);
            });
            
            const boardWidth = bounds.right - bounds.left;
            const boardHeight = bounds.bottom - bounds.top;
            
            // –¶–µ–Ω—Ç—Ä –ø–æ–ª—è –≤ –µ–≥–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
            const boardCenterX = (bounds.left + bounds.right) / 2;
            const boardCenterY = (bounds.top + bounds.bottom) / 2;
            
            // –í—ã—á–∏—Å–ª—è–µ–º –º–∞—Å—à—Ç–∞–±, —á—Ç–æ–±—ã –ø–æ–ª–µ –ø–æ–º–µ—â–∞–ª–æ—Å—å –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –∑–∞–ø–∞—Å–æ–º
            const padding = 20;
            const scaleX = (containerWidth - padding * 2) / boardWidth;
            const scaleY = (containerHeight - padding * 2) / boardHeight;
            const scale = Math.min(scaleX, scaleY, 1.5); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–±
            
            // –°–º–µ—â–∞–µ–º –≤—Å–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–∞–∫, —á—Ç–æ–±—ã —Ü–µ–Ω—Ç—Ä –ø–æ–ª—è –±—ã–ª –≤ (0, 0)
            const offsetX = -boardCenterX;
            const offsetY = -boardCenterY;
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–æ–ª—è (–∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª—É—á–µ–Ω—ã —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω–æ)
            // left –∏ top –∑–∞–¥–∞—é—Ç—Å—è –≤ CSS, –∑–¥–µ—Å—å —Ç–æ–ª—å–∫–æ transform
            boardEl.style.transform = `translate(-50%, -50%) scale(${scale})`;
            boardEl.style.transformOrigin = 'center center';
            
            board.forEach((hex, index) => {
                const pos = hexToPixel(hex.q - centerQ, hex.r - centerR, BASE_HEX_SIZE);
                const cell = document.createElement('div');
                cell.className = 'hex-cell';
                cell.id = `hex-${hex.q}-${hex.r}`;
                // –ü–æ–∑–∏—Ü–∏–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ü–µ–Ω—Ç—Ä–∞ –ø–æ–ª—è (–∫–æ—Ç–æ—Ä—ã–π —Ç–µ–ø–µ—Ä—å –≤ (0,0))
                // –°–º–µ—â–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞ offset, —á—Ç–æ–±—ã —Ü–µ–Ω—Ç—Ä –ø–æ–ª—è –±—ã–ª –≤ (0,0)
                // –ò —Å–º–µ—â–∞–µ–º –Ω–∞ –ø–æ–ª–æ–≤–∏–Ω—É —Ä–∞–∑–º–µ—Ä–∞ –∫–ª–µ—Ç–∫–∏ –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –∫–ª–µ—Ç–∫–∏
                const cellHalfSize = BASE_HEX_SIZE;
                cell.style.left = `${pos.x + offsetX - cellHalfSize}px`;
                cell.style.top = `${pos.y + offsetY - cellHalfSize}px`;
                
                const key = `${hex.q},${hex.r}`;
                const isOpened = gameState.opened.has(key);
                const isFlagged = gameState.flagged.has(key);
                const isMine = gameState.mines.has(key);
                
                let svg = '';
                if (isOpened) {
                    if (isMine) {
                        svg = `<svg viewBox="0 0 100 100"><polygon points="50,5 90,25 90,75 50,95 10,75 10,25" class="exploded" fill="#ff0000"/><text x="50" y="50" class="hex-text mine">üí£</text></svg>`;
                    } else {
                        const count = countAdjacentMines(hex.q, hex.r, gameState.mines);
                        if (count > 0) {
                            svg = `<svg viewBox="0 0 100 100"><polygon points="50,5 90,25 90,75 50,95 10,75 10,25" class="opened" fill="#ffffff" stroke="#bbb" stroke-width="1"/><text x="50" y="50" class="hex-text number-${count}">${count}</text></svg>`;
                        } else {
                            svg = `<svg viewBox="0 0 100 100"><polygon points="50,5 90,25 90,75 50,95 10,75 10,25" class="opened" fill="#ffffff" stroke="#bbb" stroke-width="1"/></svg>`;
                        }
                    }
                } else if (isFlagged) {
                    svg = `<svg viewBox="0 0 100 100"><polygon points="50,5 90,25 90,75 50,95 10,75 10,25" class="flagged" fill="#ff6b6b"/><text x="50" y="50" class="hex-text flag">üö©</text></svg>`;
                } else {
                    svg = `<svg viewBox="0 0 100 100"><polygon points="50,5 90,25 90,75 50,95 10,75 10,25" class="closed" fill="#d0d8e0" stroke="#7a8a9a" stroke-width="3"/></svg>`;
                }
                
                cell.innerHTML = svg;
                
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –º—ã—à–∏
                cell.addEventListener('click', (e) => {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –±—ã–ª–æ –ª–∏ —ç—Ç–æ –¥–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ
                    if (!cell.dataset.longPress) {
                        handleCellClick(e, hex.q, hex.r);
                    }
                    cell.dataset.longPress = 'false';
                });
                
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–∞–≤–æ–≥–æ –∫–ª–∏–∫–∞ (–¥–µ—Å–∫—Ç–æ–ø)
                cell.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    handleRightClick(hex.q, hex.r);
                });
                
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–µ–Ω—Å–æ—Ä–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
                let touchStartTime = 0;
                let touchTimer = null;
                
                cell.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touchStartTime = Date.now();
                    cell.dataset.longPress = 'false';
                    
                    touchTimer = setTimeout(() => {
                        cell.dataset.longPress = 'true';
                        handleRightClick(hex.q, hex.r);
                        // –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
                        cell.style.transform = 'scale(0.9)';
                        setTimeout(() => {
                            cell.style.transform = '';
                        }, 200);
                    }, 500); // 500ms –¥–ª—è –¥–æ–ª–≥–æ–≥–æ –Ω–∞–∂–∞—Ç–∏—è
                }, { passive: false });
                
                cell.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    clearTimeout(touchTimer);
                    
                    const touchDuration = Date.now() - touchStartTime;
                    if (touchDuration < 500 && !cell.dataset.longPress) {
                        // –ö–æ—Ä–æ—Ç–∫–æ–µ –Ω–∞–∂–∞—Ç–∏–µ - –æ—Ç–∫—Ä—ã—Ç—å –∫–ª–µ—Ç–∫—É
                        handleCellClick(e, hex.q, hex.r);
                    }
                    cell.dataset.longPress = 'false';
                }, { passive: false });
                
                cell.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    clearTimeout(touchTimer);
                    cell.dataset.longPress = 'false';
                }, { passive: false });
                
                boardEl.appendChild(cell);
            });
            
            updateStats();
        }

        function handleCellClick(e, q, r) {
            if (gameState.gameOver || gameState.gameWon) return;
            
            const key = `${q},${r}`;
            if (gameState.flagged.has(key)) return;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å–ª–∏ –∫–ª–∏–∫–Ω—É—Ç–∞ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–∞—è –∫–ª–µ—Ç–∫–∞ —Å —á–∏—Å–ª–æ–º
            if (gameState.opened.has(key)) {
                const count = countAdjacentMines(q, r, gameState.mines);
                if (count > 0) {
                    // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ—Å–µ–¥–Ω–∏—Ö –∫–ª–µ—Ç–æ–∫ —Å —Ñ–ª–∞–≥–∞–º–∏
                    const adjacent = getAdjacentHexes(q, r, gameState.board);
                    let flaggedCount = 0;
                    for (const adj of adjacent) {
                        const adjKey = `${adj.q},${adj.r}`;
                        if (gameState.flagged.has(adjKey)) {
                            flaggedCount++;
                        }
                    }
                    
                    // –ï—Å–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–ª–∞–≥–æ–≤ —Ä–∞–≤–Ω–æ —á–∏—Å–ª—É –Ω–∞ –∫–ª–µ—Ç–∫–µ, –æ—Ç–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ —Å–æ—Å–µ–¥–Ω–∏–µ –∫—Ä–æ–º–µ –ø–æ–º–µ—á–µ–Ω–Ω—ã—Ö —Ñ–ª–∞–≥–æ–º
                    if (flaggedCount === count) {
                        let openedAny = false;
                        for (const adj of adjacent) {
                            const adjKey = `${adj.q},${adj.r}`;
                            if (!gameState.flagged.has(adjKey) && !gameState.opened.has(adjKey)) {
                                const result = openCell(adj.q, adj.r, gameState.board, gameState.mines, gameState.opened, gameState.flagged);
                                if (result === 'mine') {
                                    gameState.gameOver = true;
                                    revealAllMines();
                                    renderBoard();
                                    document.getElementById('gameOver').classList.remove('hidden');
                                    return;
                                }
                                openedAny = true;
                            }
                        }
                        
                        if (openedAny) {
                            checkWin();
                            renderBoard();
                        }
                        return;
                    }
                }
                return; // –ö–ª–µ—Ç–∫–∞ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–∞ –∏ –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è
            }
            
            // –ü–µ—Ä–≤—ã–π –∫–ª–∏–∫ - —Ä–∞–∑–º–µ—â–∞–µ–º –º–∏–Ω—ã, –∏–∑–±–µ–≥–∞—è —ç—Ç–æ–π –∫–ª–µ—Ç–∫–∏ –∏ –µ—ë —Å–æ—Å–µ–¥–µ–π
            if (gameState.firstClick) {
                const { board } = generateHexagonalBoard(gameState.size);
                gameState.board = board;
                const totalCells = board.length;
                const mineCount = Math.floor(totalCells * 0.15);
                
                // –ò—Å–∫–ª—é—á–∞–µ–º –ø–µ—Ä–≤—ã–π –∫–ª–∏–∫ –∏ –µ–≥–æ —Å–æ—Å–µ–¥–µ–π
                const exclude = new Set([`${q},${r}`]);
                const adjacent = getAdjacentHexes(q, r, board);
                adjacent.forEach(adj => exclude.add(`${adj.q},${adj.r}`));
                
                gameState.mines = placeMines(board, mineCount, exclude);
                gameState.minesCount = mineCount;
                gameState.firstClick = false;
            }
            
            const result = openCell(q, r, gameState.board, gameState.mines, gameState.opened, gameState.flagged);
            
            if (result === 'mine') {
                gameState.gameOver = true;
                revealAllMines();
                renderBoard();
                document.getElementById('gameOver').classList.remove('hidden');
                return;
            }
            
            checkWin();
            renderBoard();
        }

        function handleRightClick(q, r) {
            if (gameState.gameOver || gameState.gameWon) return;
            
            const key = `${q},${r}`;
            if (gameState.opened.has(key)) return;
            
            if (gameState.flagged.has(key)) {
                gameState.flagged.delete(key);
            } else {
                gameState.flagged.add(key);
            }
            
            updateStats();
            renderBoard();
            checkWin();
        }

        function revealAllMines() {
            gameState.mines.forEach(mineKey => {
                const [q, r] = mineKey.split(',').map(Number);
                if (!gameState.opened.has(mineKey)) {
                    gameState.opened.add(mineKey);
                }
            });
        }

        function checkWin() {
            if (gameState.gameOver || gameState.firstClick) return;
            
            const totalCells = gameState.board.length;
            const openedCount = gameState.opened.size;
            const mineCount = gameState.mines.size;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–∏–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
            if (mineCount === 0 || mineCount !== gameState.minesCount) {
                return; // –ò–≥—Ä–∞ –µ—â–µ –Ω–µ –Ω–∞—á–∞–ª–∞—Å—å –∏–ª–∏ –º–∏–Ω—ã –Ω–µ —Ä–∞–∑–º–µ—â–µ–Ω—ã
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ù–ò –û–î–ù–ê –º–∏–Ω–∞ –Ω–µ –æ—Ç–∫—Ä—ã—Ç–∞
            let hasOpenedMine = false;
            for (const openedKey of gameState.opened) {
                if (gameState.mines.has(openedKey)) {
                    hasOpenedMine = true;
                    break;
                }
            }
            
            if (hasOpenedMine) {
                return; // –û—Ç–∫—Ä—ã—Ç–∞ –º–∏–Ω–∞ - —ç—Ç–æ –ø–æ—Ä–∞–∂–µ–Ω–∏–µ, –Ω–µ –ø–æ–±–µ–¥–∞
            }
            
            // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∫–ª–µ—Ç–æ–∫ –ë–ï–ó –º–∏–Ω
            let openedNonMines = 0;
            for (const openedKey of gameState.opened) {
                if (!gameState.mines.has(openedKey)) {
                    openedNonMines++;
                }
            }
            
            // –ü–æ–±–µ–¥–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç—ã –í–°–ï –∫–ª–µ—Ç–∫–∏ –ë–ï–ó –º–∏–Ω
            const totalNonMines = totalCells - mineCount;
            
            if (openedNonMines === totalNonMines) {
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –≤—Å–µ –º–∏–Ω—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –ø–æ–º–µ—á–µ–Ω—ã —Ñ–ª–∞–≥–∞–º–∏
                let allMinesFlagged = true;
                for (const mineKey of gameState.mines) {
                    if (!gameState.flagged.has(mineKey)) {
                        allMinesFlagged = false;
                        break;
                    }
                }
                
                // –ü–æ–±–µ–¥–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤—Å–µ –º–∏–Ω—ã –ø–æ–º–µ—á–µ–Ω—ã —Ñ–ª–∞–≥–∞–º–∏
                if (allMinesFlagged && gameState.flagged.size === mineCount) {
                    gameState.gameWon = true;
                    document.getElementById('gameWon').classList.remove('hidden');
                }
            }
        }

        function updateStats() {
            document.getElementById('flagsCount').textContent = gameState.flagged.size;
            document.getElementById('minesCount').textContent = gameState.minesCount;
            document.getElementById('openedCount').textContent = gameState.opened.size;
        }

        function newGame() {
            console.log('newGame() called');
            
            const sizeSelect = document.getElementById('sizeSelect');
            if (!sizeSelect) {
                console.error('sizeSelect element not found!');
                return;
            }
            
            const size = parseInt(sizeSelect.value);
            if (isNaN(size)) {
                console.error('Invalid size value:', sizeSelect.value);
                return;
            }
            
            console.log('Starting new game with size:', size);
            
            // –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
            gameState = {
                size: size,
                mines: new Set(),
                opened: new Set(),
                flagged: new Set(),
                board: [],  // –ü—É—Å—Ç–æ–µ –ø–æ–ª–µ - –±—É–¥–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ –≤ renderBoard
                gameOver: false,
                gameWon: false,
                firstClick: true,
                minesCount: 0
            };
            
            // –°–∫—Ä—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞
            const gameOverEl = document.getElementById('gameOver');
            const gameWonEl = document.getElementById('gameWon');
            if (gameOverEl) gameOverEl.classList.add('hidden');
            if (gameWonEl) gameWonEl.classList.add('hidden');
            
            // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            updateStats();
            
            // –†–µ–Ω–¥–µ—Ä–∏–º –Ω–æ–≤–æ–µ –ø–æ–ª–µ
            renderBoard();
        }

        // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–æ–±–∏–ª—å–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –∏ –ø–æ–∫–∞–∑ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–π –ø–æ–¥—Å–∫–∞–∑–∫–∏
        function updateHintForDevice() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                          || (window.innerWidth <= 768);
            
            const desktopHint = document.getElementById('desktopHint');
            const mobileHint = document.getElementById('mobileHint');
            
            if (desktopHint && mobileHint) {
                if (isMobile) {
                    desktopHint.style.display = 'none';
                    mobileHint.style.display = 'inline';
                } else {
                    desktopHint.style.display = 'inline';
                    mobileHint.style.display = 'none';
                }
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∏ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        let resizeTimer = null;
        function handleResize() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                if (gameState.board && gameState.board.length > 0) {
                    renderBoard();
                }
                updateHintForDevice();
            }, 250); // –î–µ–±–∞—É–Ω—Å –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        document.addEventListener('DOMContentLoaded', () => {
            updateHintForDevice();
            window.addEventListener('resize', handleResize);
            newGame();
        });
    </script>
</body>
</html>
